{
  "Block Entity Class": {
    "prefix": "blockentity",
    "description": "Create a block entity class",
    "body": [
      "public class ${1:MyBlockEntity} extends BlockEntity {",
      "    ",
      "    public ${1:MyBlockEntity}(BlockPos pos, BlockState state) {",
      "        super(${2:MOD_BLOCK_ENTITIES.MY_BLOCK_ENTITY}, pos, state);",
      "    }",
      "    ",
      "    @Override",
      "    public void readNbt(NbtCompound nbt) {",
      "        super.readNbt(nbt);",
      "        ${3:// Read NBT data}",
      "    }",
      "    ",
      "    @Override",
      "    protected void writeNbt(NbtCompound nbt) {",
      "        super.writeNbt(nbt);",
      "        ${4:// Write NBT data}",
      "    }",
      "}",
      "$0"
    ]
  },

  "Block Entity Registration": {
    "prefix": "blockentity.register",
    "description": "Register a block entity type",
    "body": [
      "public static final BlockEntityType<${1:MyBlockEntity}> ${2:MY_BLOCK_ENTITY} = Registry.register(",
      "    Registries.BLOCK_ENTITY_TYPE,",
      "    Identifier.of(${3:MOD_ID}, \"${4:my_block_entity}\"),",
      "    BlockEntityType.Builder.create(${1:MyBlockEntity}::new, ${5:MOD_BLOCKS.MY_BLOCK}).build()",
      ");",
      "$0"
    ]
  },

  "Block Entity with Inventory": {
    "prefix": "blockentity.inventory",
    "description": "Block entity implementing inventory",
    "body": [
      "public class ${1:MyBlockEntity} extends BlockEntity implements Inventory {",
      "    private final DefaultedList<ItemStack> inventory = DefaultedList.ofSize(${2:9}, ItemStack.EMPTY);",
      "    ",
      "    public ${1:MyBlockEntity}(BlockPos pos, BlockState state) {",
      "        super(${3:MOD_BLOCK_ENTITIES.MY_BLOCK_ENTITY}, pos, state);",
      "    }",
      "    ",
      "    @Override",
      "    public int size() {",
      "        return inventory.size();",
      "    }",
      "    ",
      "    @Override",
      "    public boolean isEmpty() {",
      "        return inventory.stream().allMatch(ItemStack::isEmpty);",
      "    }",
      "    ",
      "    @Override",
      "    public ItemStack getStack(int slot) {",
      "        return inventory.get(slot);",
      "    }",
      "    ",
      "    @Override",
      "    public ItemStack removeStack(int slot, int amount) {",
      "        ItemStack result = Inventories.splitStack(inventory, slot, amount);",
      "        if (!result.isEmpty()) {",
      "            markDirty();",
      "        }",
      "        return result;",
      "    }",
      "    ",
      "    @Override",
      "    public ItemStack removeStack(int slot) {",
      "        return Inventories.removeStack(inventory, slot);",
      "    }",
      "    ",
      "    @Override",
      "    public void setStack(int slot, ItemStack stack) {",
      "        inventory.set(slot, stack);",
      "        if (stack.getCount() > getMaxCountPerStack()) {",
      "            stack.setCount(getMaxCountPerStack());",
      "        }",
      "        markDirty();",
      "    }",
      "    ",
      "    @Override",
      "    public boolean canPlayerUse(PlayerEntity player) {",
      "        return Inventory.canPlayerUse(this, player);",
      "    }",
      "    ",
      "    @Override",
      "    public void clear() {",
      "        inventory.clear();",
      "    }",
      "    ",
      "    @Override",
      "    public void readNbt(NbtCompound nbt) {",
      "        super.readNbt(nbt);",
      "        Inventories.readNbt(nbt, inventory);",
      "    }",
      "    ",
      "    @Override",
      "    protected void writeNbt(NbtCompound nbt) {",
      "        super.writeNbt(nbt);",
      "        Inventories.writeNbt(nbt, inventory);",
      "    }",
      "}",
      "$0"
    ]
  },

  "Tickable Block Entity": {
    "prefix": "blockentity.tickable",
    "description": "Block entity with tick method",
    "body": [
      "public class ${1:MyBlockEntity} extends BlockEntity {",
      "    ",
      "    public ${1:MyBlockEntity}(BlockPos pos, BlockState state) {",
      "        super(${2:MOD_BLOCK_ENTITIES.MY_BLOCK_ENTITY}, pos, state);",
      "    }",
      "    ",
      "    public static void tick(World world, BlockPos pos, BlockState state, ${1:MyBlockEntity} blockEntity) {",
      "        if (world.isClient) return;",
      "        ${3:// Server-side tick logic}",
      "    }",
      "    ",
      "    @Override",
      "    public void readNbt(NbtCompound nbt) {",
      "        super.readNbt(nbt);",
      "    }",
      "    ",
      "    @Override",
      "    protected void writeNbt(NbtCompound nbt) {",
      "        super.writeNbt(nbt);",
      "    }",
      "}",
      "$0"
    ]
  },

  "Block with Entity": {
    "prefix": "block.withentity",
    "description": "Block with BlockEntity implementation",
    "body": [
      "public class ${1:MyBlock} extends BlockWithEntity {",
      "    ",
      "    public ${1:MyBlock}(Settings settings) {",
      "        super(settings);",
      "    }",
      "    ",
      "    @Override",
      "    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {",
      "        return new ${2:MyBlockEntity}(pos, state);",
      "    }",
      "    ",
      "    @Override",
      "    public BlockRenderType getRenderType(BlockState state) {",
      "        return BlockRenderType.${3:MODEL};",
      "    }",
      "    ",
      "    ${4:// @Override}",
      "    ${5:// public <T extends BlockEntity> BlockEntityTicker<T> getTicker(World world, BlockState state, BlockEntityType<T> type) \\{}",
      "    ${6://     return checkType(type, MOD_BLOCK_ENTITIES.MY_BLOCK_ENTITY, MyBlockEntity::tick);}",
      "    ${7:// \\}}",
      "}",
      "$0"
    ]
  }
}
